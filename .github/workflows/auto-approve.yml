name: Auto Approve PRs

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: write
  pull-requests: write
  actions: write

jobs:
  validate:
    runs-on: ubuntu-latest
    outputs:
      mergeable: ${{ steps.check-mergeable.outputs.mergeable }}
    steps:
      - name: Block non-development PRs to production
        if: github.event.pull_request.base.ref == 'production' && github.event.pull_request.head.ref != 'development'
        uses: actions/github-script@v7
        with:
          script: |
            const head = context.payload.pull_request.head.ref;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: `❌ **PR rejected:** Only the \`development\` branch can merge into \`production\`. This PR is from \`${head}\`. Please target \`development\` instead.`,
            });
            core.setFailed(`PRs to production must come from development, not ${head}`);

      - name: Wait for mergeability check
        uses: actions/github-script@v7
        id: check-mergeable
        with:
          script: |
            // GitHub needs a moment to compute mergeability after PR events
            let mergeable = null;
            let attempts = 0;
            const maxAttempts = 10;

            while (mergeable === null && attempts < maxAttempts) {
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number,
              });

              mergeable = pr.mergeable;

              if (mergeable === null) {
                attempts++;
                core.info(`Mergeability not yet computed, retrying (${attempts}/${maxAttempts})...`);
                await new Promise(r => setTimeout(r, 3000));
              }
            }

            if (mergeable === null) {
              core.setFailed('Could not determine mergeability after maximum retries');
              return;
            }

            core.setOutput('mergeable', mergeable.toString());
            core.info(`PR is mergeable: ${mergeable}`);

      - name: Post conflict notice
        if: steps.check-mergeable.outputs.mergeable == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            // Check if a conflict comment already exists to avoid duplicates
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
            });

            const conflictComment = comments.find(c =>
              c.user.login === 'github-actions[bot]' &&
              c.body.includes('merge conflicts detected')
            );

            if (!conflictComment) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: '⚠️ **Auto-approve skipped:** merge conflicts detected. Please resolve conflicts and push again.',
              });
            }
            core.info('PR has merge conflicts — skipping approval');

      - uses: actions/checkout@v4
        if: steps.check-mergeable.outputs.mergeable == 'true'

      - name: Setup Node
        if: steps.check-mergeable.outputs.mergeable == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        if: steps.check-mergeable.outputs.mergeable == 'true'
        run: npm ci

      - name: Run linter
        if: steps.check-mergeable.outputs.mergeable == 'true'
        run: npm run lint

      - name: Run tests
        if: steps.check-mergeable.outputs.mergeable == 'true'
        run: npm test -- --run

      - name: Build
        if: steps.check-mergeable.outputs.mergeable == 'true'
        run: npm run build

  auto-approve:
    needs: validate
    if: needs.validate.outputs.mergeable == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Approve PR
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
              event: 'APPROVE',
              body: 'Auto-approved: no merge conflicts, lint/tests/build passed.',
            });
            core.info('PR approved successfully');

      - name: Merge PR
        uses: actions/github-script@v7
        with:
          script: |
            // Use regular merge for development → production to preserve history sync.
            // Squash merge for feature branches → development to keep clean history.
            const baseBranch = context.payload.pull_request.base.ref;
            const mergeMethod = baseBranch === 'production' ? 'merge' : 'squash';
            core.info(`Merging with method: ${mergeMethod} (base: ${baseBranch})`);

            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
              merge_method: mergeMethod,
            });
            core.info('PR merged successfully');

      - name: Trigger deploy workflow
        uses: actions/github-script@v7
        with:
          script: |
            // GITHUB_TOKEN merges don't trigger push events for other workflows.
            // Explicitly dispatch the deploy workflow for the target branch.
            const baseBranch = context.payload.pull_request.base.ref;
            const workflowFile = baseBranch === 'production'
              ? 'deploy-production.yml'
              : baseBranch === 'development'
              ? 'deploy-development.yml'
              : null;

            if (workflowFile) {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workflowFile,
                ref: baseBranch,
              });
              core.info(`Triggered ${workflowFile} for ${baseBranch}`);
            } else {
              core.info(`No deploy workflow for base branch: ${baseBranch}`);
            }

      - name: Delete branch
        uses: actions/github-script@v7
        with:
          script: |
            const branch = context.payload.pull_request.head.ref;
            const protectedBranches = ['development', 'production'];

            if (protectedBranches.includes(branch)) {
              core.info(`Branch '${branch}' is a protected branch — skipping deletion`);
              return;
            }

            await github.rest.git.deleteRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `heads/${branch}`,
            });
            core.info(`Branch '${branch}' deleted successfully`);
